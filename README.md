## SynchronizeThreadNetoLess
### Задача 1 (обязательная)
В итоге:
1. Заведите HashMap в статическом поле public static final Map<Integer, Integer> sizeToFreq
2. При обработке каждой строки увеличьте счётчик в мапе
3. Используйте synchronized для потокобезопасного доступа к мапе

### Задача 2 (обязательная)
В итоге:

1. Создайте отдельный поток для вывода на экран лидера в частотной мапе
2. В этом потоке должен быть бесконечный цикл с проверкой на прерванность while (!Thread.interrupted()) { ... }
3. В цикле перед каждым поиском и выводом на экран максимума в мапе поток должен ждать сигнала от заполняющих мапу потоков
4. В заполняющих мапу потоках добавьте отправку сигнала печатающему максимумы потоку
5. После завершения всех считающих потоков прервите печатающий поток через thread.interrupt()
